@startuml
title TP - Sistema de Gestión de Partidos Deportivos (MVC + Patrones)

skinparam packageStyle rectangle
skinparam maxMessageSize 60
skinparam linetype ortho

' ========== PÁGINA 1: MVC y Model ==========
package "MVC" {
  class UserController {
    + registerUser(username: String, email: String, password: String, favoriteSport: SportType, skillLevel: SkillLevel, location: Location): User
  }
  class MatchController {
    + create(sport: SportType, requiredPlayers: int, duration: int, location: Location, locationDescription: String, start: LocalDateTime): Match
    + search(sport: SportType): Collection<Match>
    + searchNearby(sport: SportType, userLocation: Location): Collection<Match>
    + join(matchId: String, username: String)
  }
  class InteractiveMenu {
    + run(): void
    - register(): void
    - login(): void
    - createMatch(): void
    - searchMatches(): void
    - joinMatch(): void
  }
  
  UserController --> UserRepository : usa
  MatchController --> MatchService : usa
  InteractiveMenu --> UserController
  InteractiveMenu --> MatchController
  InteractiveMenu --> SessionService
}

package "Model" {
  class User {
    - id: String
    - username: String
    - email: String
    - passwordHash: String
    - favoriteSport: SportType
    - skillLevel: SkillLevel
    - location: Location
  }
  
  class Match {
    - id: String
    - sportType: SportType
    - requiredPlayers: int
    - durationMinutes: int
    - location: Location
    - locationDescription: String
    - startDateTime: LocalDateTime
    - players: List<User>
    - observers: List<NotificationObserver>
    - state: MatchState
    + join(user: User)
    + confirm()
    + start()
    + finish()
    + cancel()
    + addObserver(o: NotificationObserver)
    + notifyObservers(event: MatchEvent)
  }
  
  class Location {
    - latitude: double
    - longitude: double
    + getLatitude(): double
    + getLongitude(): double
  }
  
  User --> SportType : referencia
  User --> SkillLevel : referencia
  User --> Location : tiene
  Match --> SportType : referencia
  Match --> Location : tiene
  Match "*" o-- "*" User : jugadores
}

newpage

' ========== PÁGINA 2: Catálogos, State y Strategy ==========
package "Catálogos (desde JSON)" {
  class ReferenceData {
    + sport(name: String): SportType
    + skill(name: String): SkillLevel
    + channel(name: String): NotificationChannel
    + event(name: String): MatchEvent
    + defaultChannels(): List<NotificationChannel>
  }
  
  class SportType {
    + name: String
  }
  
  class SkillLevel {
    + name: String
    + rank: int
  }
  
  class NotificationChannel {
    + name: String
  }
  
  class MatchEvent {
    + name: String
  }
  
  ReferenceData --> SportType : proporciona
  ReferenceData --> SkillLevel : proporciona
  ReferenceData --> NotificationChannel : proporciona
  ReferenceData --> MatchEvent : proporciona
}

package "State (Estados de Partido)" {
  interface MatchState {
    + name(): String
    + onPlayerJoined(match: Match)
    + confirm(match: Match)
    + start(match: Match)
    + finish(match: Match)
    + cancel(match: Match)
  }
  
  class NeedPlayersState
  class AssembledState
  class ConfirmedState
  class InProgressState
  class FinishedState
  class CanceledState
  
  Match --> MatchState : tiene estado
  MatchState <|.. NeedPlayersState
  MatchState <|.. AssembledState
  MatchState <|.. ConfirmedState
  MatchState <|.. InProgressState
  MatchState <|.. FinishedState
  MatchState <|.. CanceledState
}

package "Strategy (Emparejamiento)" {
  interface PlayerMatchingStrategy {
    + suggestPlayers(match: Match, candidates: Collection<User>): List<User>
  }
  
  class BySkillLevelStrategy {
    + suggestPlayers(match: Match, candidates: Collection<User>): List<User>
  }
  
  class MatchingService {
    - strategy: PlayerMatchingStrategy
    + setStrategy(s: PlayerMatchingStrategy)
    + suggestPlayers(match: Match, candidates: Collection<User>): List<User>
  }
  
  PlayerMatchingStrategy <|.. BySkillLevelStrategy
  MatchingService --> PlayerMatchingStrategy : usa
}

newpage

' ========== PÁGINA 3: Notificaciones y Repository ==========
package "Observer + Factory + Facade (Notificaciones)" {
  interface NotificationObserver {
    + onMatchEvent(match: Match, event: MatchEvent)
  }
  
  Match --> NotificationObserver : notifica
  
  interface Notifier {
    + notify(user: User, match: Match, event: MatchEvent)
  }
  
  class NotificationFactory {
    + create(channel: NotificationChannel): Notifier
  }
  
  class NotificationFacade {
    - factory: NotificationFactory
    + notifyAllChannels(user: User, match: Match, event: MatchEvent)
  }
  
  class EmailNotifier
  class PushNotifier
  
  NotificationFactory --> Notifier : crea
  NotificationFacade --> NotificationFactory : usa
  NotificationFacade --> Notifier : usa
  Notifier <|.. EmailNotifier
  Notifier <|.. PushNotifier
  EmailNotifier --> EmailService : usa
  
  note right of NotificationFacade
    Facade simplifica la notificación
    por múltiples canales (Email, Push)
  end note
  
  note right of NotificationFactory
    Factory crea instancias de Notifier
    según el canal solicitado
  end note
}

package "Repository" {
  interface UserRepository {
    + save(user: User): User
    + findById(id: String): Optional<User>
    + findByUsername(username: String): Optional<User>
    + findAll(): Collection<User>
  }
  
  interface MatchRepository {
    + save(match: Match): Match
    + findById(id: String): Optional<Match>
    + findAll(): Collection<Match>
    + findBySport(sportType: SportType): Collection<Match>
  }
  
  class InMemoryUserRepository
  class InMemoryMatchRepository
  
  UserRepository <|.. InMemoryUserRepository
  MatchRepository <|.. InMemoryMatchRepository
}

newpage

' ========== PÁGINA 4: Service y Utilidades ==========
package "Service" {
  class MatchService {
    - matchRepository: MatchRepository
    - userRepository: UserRepository
    - matchingService: MatchingService
    - notificationFacade: NotificationFacade
    - locationService: LocationService
    + createMatch(sport: SportType, requiredPlayers: int, duration: int, location: Location, locationDescription: String, start: LocalDateTime): Match
    + joinMatch(matchId: String, username: String)
    + suggestPlayers(matchId: String): List<User>
    + findNearby(sport: SportType, userLocation: Location): Collection<Match>
    + getDistance(userLocation: Location, match: Match): double
    + confirm(matchId: String)
    + startIfTime(matchId: String)
    + finish(matchId: String)
    + cancel(matchId: String)
  }
  
  class SessionService {
    - userRepository: UserRepository
    - currentUser: User
    + login(username: String, password: String): boolean
    + logout(): void
    + getCurrentUser(): User
    + isLoggedIn(): boolean
  }
  
  class LocationService {
    + calculateDistance(loc1: Location, loc2: Location): double
    + formatDistance(distanceKm: double): String
  }
  
  class EmailService {
    - smtpHost: String
    - smtpPort: int
    - username: String
    - password: String
    + sendEmail(to: String, subject: String, body: String): boolean
    + isConfigured(): boolean
  }
  
  MatchService --> MatchRepository
  MatchService --> UserRepository
  MatchService --> MatchingService
  MatchService --> NotificationFacade
  MatchService --> LocationService : usa
  SessionService --> UserRepository
  EmailNotifier --> EmailService : usa
}

package "Utilidades" {
  class MatchIdGenerator {
    {static} + generate(): String
  }
  
  MatchIdGenerator ..> Match : genera ID
}

' Integraciones clave
MatchController --> MatchService
UserController --> UserRepository
InteractiveMenu --> SessionService
Match --> NotificationObserver : notifica eventos

note right of Match
  Estados requeridos:
  - "Necesitamos jugadores" (NeedPlayersState)
  - "Partido armado" (AssembledState)
  - "Confirmado" (ConfirmedState)
  - "En juego" (InProgressState)
  - "Finalizado" (FinishedState)
  - "Cancelado" (CanceledState)
end note

legend right
  Patrones implementados:
  - MVC: Controller, View, Model separados
  - State: Ciclo de vida del Match
  - Strategy: Emparejamiento de jugadores
  - Observer: Eventos de notificación
  - Factory: Creación de Notifiers
  - Facade: Simplificación de notificaciones
  - Repository: Abstracción de persistencia
  
  Funcionalidades:
  - Búsqueda por cercanía (LocationService)
  - IDs legibles (MatchIdGenerator)
  - Notificaciones por email real
  
  Datos desde JSON:
  - ReferenceData carga SportType, SkillLevel,
    NotificationChannel, MatchEvent desde
    mockdata.json (no desde BD)
end legend

@enduml

